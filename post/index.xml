<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on iteratively.io</title><link>https://iteratively.io/post/</link><description>Recent content in Posts on iteratively.io</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 24 Aug 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://iteratively.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>How Many Cars Would Waymo Need in Chicago?</title><link>https://iteratively.io/p/drt-chicago/</link><pubDate>Sun, 24 Aug 2025 00:00:00 +0000</pubDate><guid>https://iteratively.io/p/drt-chicago/</guid><description>&lt;img src="https://iteratively.io/p/drt-chicago/cover.jpg" alt="Featured image of post How Many Cars Would Waymo Need in Chicago?" />&lt;h2 id="-motivation">🚀 Motivation
&lt;/h2>&lt;p>Waymo is rapidly expanding across the United States, rolling out autonomous ride-hailing services in city after city. The ambitions are bold — but what does it take to realistically meet urban demand with autonomous vehicles?&lt;/p>
&lt;p>This blog post explores how &lt;strong>ride-hailing simulations with MATSim DRT Contrib&lt;/strong> can help cities, mobility strategists, and tech companies estimate the fleet size required to serve real-world demand. By simulating autonomous deployments, we gain actionable insights into what a Waymo-like service would need to operate effectively in a new urban environment.&lt;/p>
&lt;p>One city stands out: &lt;strong>Chicago&lt;/strong>. The City of Chicago provides a &lt;strong>highly detailed, continuously updated ride-hailing dataset&lt;/strong> — a true hidden gem that’s often overlooked in both academic and commercial circles. It offers a rare opportunity to analyze real booking behavior at scale.&lt;/p>
&lt;p>In this post, I’ll show you how to unlock the full potential of this dataset using &lt;strong>Java, Python, &lt;a class="link" href="https://matsim.org" target="_blank" rel="noopener"
>MATSim&lt;/a>, and &lt;a class="link" href="https://www.simunto.com/" target="_blank" rel="noopener"
>Simunto&lt;/a> software&lt;/strong>. We’ll dive deep into the data and explore how simulation can turn raw demand into strategic deployment decisions.&lt;/p>
&lt;hr>
&lt;h2 id="-input-data-real-ride-hailing-trips-from-chicago">📦 Input Data: Real Ride-Hailing Trips from Chicago
&lt;/h2>&lt;p>The foundation of this analysis is a public dataset provided by the &lt;strong>City of Chicago&lt;/strong>, titled &lt;a class="link" href="https://data.cityofchicago.org/Transportation/Transportation-Network-Providers-Trips-2025-/3q84-vs9b" target="_blank" rel="noopener"
>Transportation Network Providers - Trips (2025)&lt;/a>. It contains anonymized trip-level data from ride-hailing services like Uber and Lyft, and is published under &lt;strong>Public Domain&lt;/strong> — making it freely usable for both academic and commercial purposes.&lt;/p>
&lt;p>You can access the data in two ways:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>CSV Archive Download&lt;/strong>: A full-year dump, currently around &lt;strong>12.5 GB&lt;/strong> of raw data for 2025.&lt;/li>
&lt;li>&lt;strong>API Access&lt;/strong>: Ideal for downloading specific days or weeks without handling the full dataset.&lt;/li>
&lt;/ul>
&lt;p>You can get a full overview of the provided attributes per trip check out this &lt;a class="link" href="https://data.cityofchicago.org/Transportation/Transportation-Network-Providers-Trips-2025-/6dvr-xwnh/about_data" target="_blank" rel="noopener"
>source&lt;/a>.
The so call &lt;a class="link" href="https://github.com/steffenaxer/iteratively-code-examples/blob/main/src/main/java/io/iteratively/matsim/PlansConverter.java" target="_blank" rel="noopener"
>PlansConverter&lt;/a> allows you to download and cache files day by day.
Moreover, trip demand gets transformed to MATSim compatible input.&lt;/p>
&lt;blockquote>
&lt;p>⚠️ Working on 12.5 GB csv can be a significant hurdle. That’s why I’ve created a &lt;a class="link" href="https://github.com/steffenaxer/iteratively-code-examples/blob/main/src/main/java/io/iteratively/matsim/PlansConverter.java" target="_blank" rel="noopener"
>PlansConverter&lt;/a> that lets you fetch data for selected days or entire weeks with ease.
You need to &lt;a class="link" href="https://data.cityofchicago.org/login" target="_blank" rel="noopener"
>register&lt;/a> in order to obtain an API token for my downloader.&lt;/p>&lt;/blockquote>
&lt;h2 id="-scope-of-analysis-intra-chicago-trips-only">📍 Scope of Analysis: Intra-Chicago Trips Only
&lt;/h2>&lt;p>It’s important to note that &lt;strong>pickup and dropoff coordinates are omitted&lt;/strong> whenever a trip starts or ends &lt;strong>outside the official boundaries of the City of Chicago&lt;/strong>. In such cases, fields like census tract, community area, and geolocation are left blank.&lt;/p>
&lt;p>As a result, this analysis focuses &lt;strong>exclusively on trips that both start and end within Chicago city limits&lt;/strong>. This ensures that all trips included in the simulation have valid spatial references and can be accurately mapped and analyzed. Origin and destination coordinates are represented by the census tract centroid.
I created a census tract coordinate sampler that draws random start and end coordinates within each tract area.&lt;/p>
&lt;p>By restricting the dataset to &lt;strong>intra-city trips&lt;/strong>, we can:&lt;/p>
&lt;ul>
&lt;li>Reliably reconstruct origin-destination flows&lt;/li>
&lt;li>Analyze demand patterns across community areas&lt;/li>
&lt;li>Simulate realistic operations within a well-defined urban service area&lt;/li>
&lt;/ul>
&lt;p>This scope also mirrors how autonomous ride-hailing services like Waymo typically operate — starting with clearly bounded service zones before expanding to broader regions.&lt;/p>
&lt;hr>
&lt;h2 id="-a-typical-week-of-ride-hailing-in-chicago">📊 A Typical Week of Ride-Hailing in Chicago
&lt;/h2>&lt;p>Before diving into the simulation study, let&amp;rsquo;s take a moment to explore the data. For this, I downloaded a &lt;strong>typical week of ride-hailing activity&lt;/strong> in Chicago via API access, covering the period from &lt;strong>June 2 to June 8 2025&lt;/strong>.&lt;/p>
&lt;p>This week includes a total of &lt;strong>888,610 trips&lt;/strong>.&lt;/p>
&lt;h3 id="-spatial-distribution">🗺️ Spatial Distribution
&lt;/h3>&lt;p>The spatial distribution of trips is shown in the image below:&lt;/p>
&lt;figure>&lt;img src="https://iteratively.io/p/drt-chicago/rides_count.png"
alt="Spatial Trips Distribution" width="700">
&lt;/figure>
&lt;p>As expected, demand hotspots include the &lt;strong>downtown area&lt;/strong> and especially the &lt;strong>airports&lt;/strong>, which show consistently high ride volumes.&lt;/p>
&lt;h3 id="-trip-distance-behavior">📐 Trip Distance Behavior
&lt;/h3>&lt;p>To better understand how far people travel, I visualized the distribution of trip distances:&lt;/p>
&lt;figure>&lt;img src="https://iteratively.io/p/drt-chicago/distance_distribution.png"
alt="Spatial Trips Distribution" width="700">
&lt;/figure>
&lt;p>As someone who prefers walking as little as possible, I was surprised — or maybe not — to see that the &lt;strong>American stereotype holds true&lt;/strong>: even the shortest distances, often &lt;strong>less than 2 km&lt;/strong>, are frequently covered by ride-hailing services.&lt;/p>
&lt;p>That said, it&amp;rsquo;s worth considering that &lt;strong>nighttime safety concerns&lt;/strong> may also play a role in this behavior, encouraging people to opt for a ride rather than walking through the city.&lt;/p>
&lt;h3 id="-tip-behavior-insights">💸 Tip Behavior Insights
&lt;/h3>&lt;p>Beyond trip volumes and distances, the dataset also offers &lt;strong>valuable insights into tipping behavior&lt;/strong> — something that’s often overlooked in ride-hailing analyses.
Since &lt;strong>Waymo vehicles don’t receive tips&lt;/strong>, understanding where human drivers earn the most in gratuities can reveal &lt;strong>potential pricing opportunities&lt;/strong> for autonomous fleets.&lt;/p>
&lt;p>I visualized the &lt;strong>spatial distribution of tip share&lt;/strong>, i.e., the proportion of the total fare that comes from tips. The results are intriguing:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Airports&lt;/strong> stand out as areas where passengers tend to be more generous.&lt;/li>
&lt;li>&lt;strong>Downtown&lt;/strong> and the &lt;strong>northern parts of the city&lt;/strong> also show elevated tip shares.&lt;/li>
&lt;/ul>
&lt;p>This could imply that in these regions, Waymo might need to &lt;strong>adjust pricing&lt;/strong> to compensate for the lack of tips — especially if competing with human drivers.&lt;/p>
&lt;figure>&lt;img src="https://iteratively.io/p/drt-chicago/tip_share.png"
alt="Spatial Tip Distribution" width="700">
&lt;/figure>
&lt;blockquote>
&lt;p>💬 If you’re familiar with Chicago’s neighborhoods and have a hypothesis about these patterns, feel free to share your thoughts with me on &lt;a class="link" href="https://www.linkedin.com/in/steffenaxer" target="_blank" rel="noopener"
>LinkedIn&lt;/a>!&lt;/p>&lt;/blockquote>
&lt;h3 id="-tip-vs-trip-distance">📏 Tip vs. Trip Distance
&lt;/h3>&lt;p>After this spatial analysis, I was hooked and eager to see what else the data might reveal.
Another interesting finding: &lt;strong>shorter trips tend to have proportionally higher tips&lt;/strong> than longer ones.&lt;/p>
&lt;figure>&lt;img src="https://iteratively.io/p/drt-chicago/tip_share_vs_distance_km.png"
alt="Tip Share over Trip Distance" width="700">
&lt;/figure>
&lt;h3 id="-api-download-experience">🔄 API Download Experience
&lt;/h3>&lt;p>One practical note: downloading this data via API was noticeably faster on &lt;strong>weekends&lt;/strong>. During weekdays, the endpoint was heavily loaded and slow — something to keep in mind if you&amp;rsquo;re planning to automate data access.&lt;/p>
&lt;hr>
&lt;h2 id="-simulation-study-building-a-matsim-scenario-from-real-ride-hailing-data">🧪 Simulation Study: Building a MATSim Scenario from Real Ride-Hailing Data
&lt;/h2>&lt;p>Now comes the fun part — turning raw data into a working simulation. To do this, I’ve developed a modular pipeline using three key Java classes that together build a complete &lt;strong>MATSim scenario&lt;/strong> from the Chicago TNP dataset.&lt;/p>
&lt;h3 id="-disclaimer-a-simplified-simulation-perspective">⚠️ Disclaimer: A Simplified Simulation Perspective
&lt;/h3>&lt;p>This simulation study is a &lt;strong>simplified exploration&lt;/strong> of autonomous fleet deployment using MATSim and real-world ride-hailing data. While it provides valuable insights into demand patterns and operational feasibility, it does &lt;strong>not yet include several advanced modeling components&lt;/strong> that are essential for commercial-grade applications.&lt;/p>
&lt;p>MATSim is capable of simulating much more complex systems, including:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Operational Facilities&lt;/strong>: Hubs with charging infrastructure and parking space limitations&lt;/li>
&lt;li>&lt;strong>Electric Vehicles (EVs)&lt;/strong>: Including battery consumption models and charging behavior&lt;/li>
&lt;li>&lt;strong>Service Tasks&lt;/strong>: Cleaning and maintenance&lt;/li>
&lt;li>&lt;strong>Congestion Replication&lt;/strong>: Integrating congestion pattern from HERE or TomTom&lt;/li>
&lt;/ul>
&lt;p>These elements significantly increase the complexity of the model and are crucial when building simulations for &lt;strong>real-world deployment, investment decisions, or regulatory planning&lt;/strong>.&lt;/p>
&lt;blockquote>
&lt;p>💬 I’d love to hear your thoughts! Feel free to comment on this post or reach out via LinkedIn — let me know what you&amp;rsquo;d like to see covered in the &lt;strong>next edition&lt;/strong> of this series.&lt;/p>&lt;/blockquote>
&lt;h3 id="-building-the-urban-road-network-networkconverter">🧱 Building the Urban Road Network (&lt;code>NetworkConverter&lt;/code>)
&lt;/h3>&lt;p>This class downloads and processes an &lt;strong>OpenStreetMap PBF file&lt;/strong> for the Chicago region. It clips the network to a bounding box, transforms coordinates to a local EPSG system, simplifies the network, and prepares it for &lt;strong>DRT simulation&lt;/strong> by adding the necessary transport modes.&lt;/p>
&lt;ul>
&lt;li>Uses &lt;code>SupersonicOsmNetworkReader&lt;/code> for fast parsing&lt;/li>
&lt;li>Applies &lt;code>NetworkSimplifier&lt;/code> to reduce complexity&lt;/li>
&lt;li>Adds &lt;code>drt&lt;/code> mode to all car-accessible links&lt;/li>
&lt;li>Outputs a clean MATSim network file (&lt;code>network.xml.gz&lt;/code>)&lt;/li>
&lt;/ul>
&lt;h3 id="-generating-agent-plans-from-real-trips-plansconverter">👥 Generating Agent Plans from Real Trips (&lt;code>PlansConverter&lt;/code>)
&lt;/h3>&lt;p>This class connects to the &lt;strong>City of Chicago’s TNP API&lt;/strong>, downloads trip data for a given date range, and converts each trip into a MATSim agent plan.&lt;/p>
&lt;ul>
&lt;li>Each trip becomes a &lt;code>Person&lt;/code> with a &lt;code>Plan&lt;/code> (home → drt leg → work)&lt;/li>
&lt;li>Includes attributes like &lt;code>fare&lt;/code>, &lt;code>tip&lt;/code>, &lt;code>trip_total&lt;/code>, and &lt;code>shared_trip_match&lt;/code>&lt;/li>
&lt;li>Supports sampling and census tract-based coordinate generation&lt;/li>
&lt;li>Outputs &lt;code>plans.xml.gz&lt;/code> and a CSV summary of all trips&lt;/li>
&lt;/ul>
&lt;h3 id="-orchestrating-the-full-scenario-scenariocreator">🧩 Orchestrating the Full Scenario (&lt;code>ScenarioCreator&lt;/code>)
&lt;/h3>&lt;p>This is the master class that ties everything together. It sets up directories, calls the network and plans converters, and generates a full MATSim &lt;code>config.xml&lt;/code> with all necessary modules.&lt;/p>
&lt;ul>
&lt;li>Configures DRT with advanced settings (e.g. parallel insertion, rebalancing, constraints)&lt;/li>
&lt;li>Generates a synthetic fleet (&lt;code>fleet.xml.gz&lt;/code>) based on network topology&lt;/li>
&lt;li>Sets simulation time, scoring parameters, and zone systems&lt;/li>
&lt;li>Outputs a ready-to-run MATSim scenario with real-world demand&lt;/li>
&lt;/ul>
&lt;p>With this setup, you can simulate how an autonomous fleet like Waymo might perform in Chicago — using actual demand data, realistic routing, and configurable fleet behavior.
Want to try it yourself? Try out the full &lt;a class="link" href="https://github.com/steffenaxer/iteratively-code-examples/tree/main/src/main/java/io/iteratively/matsim" target="_blank" rel="noopener"
>code&lt;/a> - If you need help. Feel free to reach out.&lt;/p>
&lt;hr>
&lt;h2 id="-results-how-many-vehicles-would-waymo-need">📈 Results: How Many Vehicles Would Waymo Need?
&lt;/h2>&lt;p>Almost like the cliffhanger in your favorite series — you’ve waited and wondered: &lt;em>How many vehicles would it take to serve all ride-hailing demand in Chicago with an autonomous fleet?&lt;/em>&lt;/p>
&lt;p>By gradually increasing the fleet size in simulation, we can estimate the number of vehicles required to keep the &lt;strong>rejection rate&lt;/strong> (i.e., unserved trip requests) around &lt;strong>10%&lt;/strong>. The following plot shows that approximately &lt;strong>3500 vehicles&lt;/strong> are needed to meet this threshold during peak demand
But that’s not the whole story. The &lt;strong>utilization of the fleet&lt;/strong> is highly uneven across the week. &lt;strong>Friday and Saturday evenings&lt;/strong> represent clear demand peaks, while the rest of the week shows significantly lower usage:&lt;/p>
&lt;figure>&lt;img src="https://iteratively.io/p/drt-chicago/occupancy_stackplot_weekday_time.png"
alt="Fleet Utilization over Time" width="700">
&lt;/figure>
&lt;p>This &lt;strong>utilization risk&lt;/strong> poses a serious economic challenge for autonomous operators like Waymo, Uber, or Lyft. Previously, this risk was absorbed by human drivers — now it shifts to the companies themselves.&lt;/p>
&lt;p>It’s likely that these providers will aim for a &lt;strong>hybrid operational model&lt;/strong>, where an autonomous fleet handles baseline demand and the human driven fleet is request &lt;strong>only during high-utilization periods&lt;/strong>. This would help mitigate the risk of underused assets and ensure a more sustainable business case.&lt;/p>
&lt;h2 id="-battery-sizing--daily-mileage-a-classic-question">🔋 Battery Sizing &amp;amp; Daily Mileage: A Classic Question
&lt;/h2>&lt;p>One of the most frequently asked technical questions in autonomous fleet planning is:&lt;br>
&lt;strong>How far does a vehicle need to drive per day?&lt;/strong>&lt;/p>
&lt;p>To answer this, I ran a simple analysis based on the simulated weekly demand.&lt;/p>
&lt;figure>&lt;img src="https://iteratively.io/p/drt-chicago/daily_distance_km.png"
alt="Daily Vehicle Mileage" width="700">
&lt;/figure>
&lt;p>The simulation revealed a mileage of &lt;strong>350 km per day&lt;/strong>. Such a workload has direct implications for:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Battery sizing&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Charging infrastructure&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Fleet rotation and maintenance cycles&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Especially for electric vehicles (EVs), this level of daily mileage requires robust energy management and operational planning.&lt;/p>
&lt;p>But it doesn’t stop at batteries:&lt;br>
🔧 &lt;strong>Other wear components&lt;/strong> such as tires, brakes, and suspension systems must also be dimensioned appropriately. High daily mileage leads to increased wear, and frequent repairs can quickly result in:&lt;/p>
&lt;ul>
&lt;li>Higher operational costs&lt;/li>
&lt;li>Increased fleet size requirements (to compensate for downtime)&lt;/li>
&lt;li>Reduced economic viability&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>💬 What do you think? Share your thoughts or hypotheses on LinkedIn — I’d love to hear what you&amp;rsquo;d explore in the next edition!&lt;/p>&lt;/blockquote>
&lt;hr>
&lt;div align="center">Stay tuned for the next iteration &lt;img src="https://iteratively.io/logo_iteratively_circle.svg" style="height:1.5em;position:relative;top:0.4em;padding-left:0.2em"> &lt;/div>
&lt;p>&lt;em>Author: Steffen Axer&lt;/em>&lt;/p></description></item><item><title>Fast &amp; Curious: How to Speed Up DRT Simulations in MATSim</title><link>https://iteratively.io/p/drt-speedup/</link><pubDate>Thu, 07 Aug 2025 00:00:00 +0000</pubDate><guid>https://iteratively.io/p/drt-speedup/</guid><description>&lt;img src="https://iteratively.io/p/drt-speedup/cover.jpg" alt="Featured image of post Fast &amp; Curious: How to Speed Up DRT Simulations in MATSim" />&lt;h2 id="-motivation">💡 Motivation
&lt;/h2>&lt;p>During the development of &lt;strong>DSim (Distributed MATSim)&lt;/strong> — as presented at &lt;a class="link" href="https://matsim.org/conferences/mum2025.html" target="_blank" rel="noopener"
>MUM 2025&lt;/a> — it became evident that &lt;strong>Demand Responsive Transport (DRT)&lt;/strong> systems pose a significant bottleneck in large-scale MATSim simulations. Especially when simulating thousands of autonomous rides, the insertion logic for unplanned requests becomes computationally expensive and limits overall scalability.&lt;/p>
&lt;p>This is problematic because &lt;strong>fast and scalable DRT simulations&lt;/strong> are crucial for system planning in &lt;strong>Autonomous Driving Mobility-as-a-Service (AD MaaS)&lt;/strong>. As fleets and demand grow, cities and operators need to regularly optimize service configurations. This requires simulation frameworks that can handle high request volumes efficiently.&lt;/p>
&lt;p>To address this, I developed the &lt;strong>ParallelUnplannedRequestInserter&lt;/strong>, a multi-threaded insertion engine designed to scale with demand and fleet size.&lt;/p>
&lt;hr>
&lt;h2 id="-conceptual-design">⚙️ Conceptual Design
&lt;/h2>&lt;p>The &lt;code>ParallelUnplannedRequestInserter&lt;/code> is a parallelized implementation of MATSim’s &lt;code>UnplannedRequestInserter&lt;/code> interface. It introduces the following key concepts:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Partitioning&lt;/strong>: Incoming DRT requests and available vehicle entries are partitioned using &lt;code>RequestsPartitioner&lt;/code> and &lt;code>VehicleEntryPartitioner&lt;/code>.&lt;/li>
&lt;li>&lt;strong>Worker Threads&lt;/strong>: Each partition is processed by a dedicated &lt;code>RequestInsertWorker&lt;/code>, which performs insertion logic independently.&lt;/li>
&lt;li>&lt;strong>Conflict Resolution&lt;/strong>: After parallel processing, insertions are consolidated. Conflicts (e.g., multiple requests assigned to the same vehicle) are resolved iteratively.&lt;/li>
&lt;li>&lt;strong>Thread Activity Logging&lt;/strong>: Optionally logs request density and active partitions over time for performance diagnostics.&lt;/li>
&lt;/ul>
&lt;p>This design enables &lt;strong>concurrent evaluation of insertion possibilities&lt;/strong>, significantly reducing simulation time for high-volume DRT scenarios.&lt;/p>
&lt;h3 id="-partitioning-strategies-explained">🧩 Partitioning Strategies Explained
&lt;/h3>&lt;p>This simulation uses two interfaced partitioning strategies to improve scalability and responsiveness in high-load DRT scenarios:&lt;/p>
&lt;h4 id="-request-partitioner">📥 Request-Partitioner
&lt;/h4>&lt;p>This partitioner (&lt;code>LoadAwareRoundRobinRequestsPartitioner&lt;/code>) distributes incoming DRT requests across multiple partitions using a &lt;strong>load-aware round-robin&lt;/strong> strategy. Unlike a static round-robin, it dynamically adjusts the number of active partitions based on the current request load and a configurable scaling function.&lt;/p>
&lt;ul>
&lt;li>For every additional &lt;strong>20 requests per minute&lt;/strong>, one additional partition is activated.&lt;/li>
&lt;li>Requests are assigned cyclically to active partitions using an internal counter.&lt;/li>
&lt;li>This ensures efficient use of resources and better parallelization under varying demand levels.&lt;/li>
&lt;li>&lt;strong>Importantly&lt;/strong>, under &lt;strong>low demand&lt;/strong>, the partitioner avoids unnecessary fragmentation of requests. This helps maintain simulation quality by reducing empty trips and rejection rates, which would otherwise increase due to overly distributed demand.&lt;/li>
&lt;/ul>
&lt;h4 id="-vehicle-partitioner">🚗 Vehicle-Partitioner
&lt;/h4>&lt;p>This partitioner (&lt;code>ShiftingRoundRobinVehicleEntryPartitioner&lt;/code>) assigns vehicles to request partitions using a &lt;strong>shifting round-robin&lt;/strong> strategy:&lt;/p>
&lt;ul>
&lt;li>Vehicles are distributed cyclically across active partitions.&lt;/li>
&lt;li>The starting index shifts with each invocation to avoid systematic bias.&lt;/li>
&lt;li>Only partitions with at least one request are considered.&lt;/li>
&lt;li>Vehicles are sorted deterministically by ID to ensure reproducibility.&lt;/li>
&lt;/ul>
&lt;p>Together, these strategies ensure that both requests and vehicles are evenly and dynamically distributed across processing threads, improving simulation performance and fairness over time.&lt;/p>
&lt;hr>
&lt;h2 id="-benchmark-results">📊 Benchmark Results
&lt;/h2>&lt;figure>&lt;img src="https://iteratively.io/p/drt-speedup/benchmark.png"
alt="Simulation Duration Comparison: Baseline vs Optimized" width="600">
&lt;/figure>
&lt;p>The chart compares simulation durations for two partitioning strategies across different agent counts:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Baseline&lt;/strong> (orange): shows a steep increase in simulation time as the number of agents grows.&lt;/li>
&lt;li>&lt;strong>Optimized&lt;/strong> (blue): maintains significantly lower durations, scaling more efficiently.&lt;/li>
&lt;/ul>
&lt;p>At &lt;strong>100,000 agents&lt;/strong>, the optimized setup is &lt;strong>1.60× faster&lt;/strong> than the baseline.&lt;br>
At &lt;strong>200,000 agents&lt;/strong>, the speedup increases to &lt;strong>2.60×&lt;/strong>.&lt;br>
An extrapolation suggests that at &lt;strong>400,000 agents&lt;/strong>, the optimized strategy could be &lt;strong>4.60× faster&lt;/strong>, highlighting its scalability advantage.&lt;/p>
&lt;p>This benchmark demonstrates how intelligent partitioning can drastically reduce simulation time in large-scale DRT scenarios.&lt;/p>
&lt;hr>
&lt;h2 id="-how-to-use">🛠️ How to Use
&lt;/h2>&lt;p>To enable the &lt;code>ParallelUnplannedRequestInserter&lt;/code> in your MATSim DRT simulation, follow these steps:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Add &lt;code>DrtParallelInserterParams&lt;/code>&lt;/strong> to your DRT config:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">DrtParallelInserterParams&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">params&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">DrtParallelInserterParams&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">params&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">setLogThreadActivity&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// Optional: enables logging&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">drtCfg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">addParameterSet&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">params&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;strong>Replace the default inserter module&lt;/strong> with the parallel version:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">controller&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">addOverridingQSimModule&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ParallelRequestInserterModule&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">drtCfg&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;strong>Choose your insertion strategy&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>For &lt;strong>Extensive Search&lt;/strong>:
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">drtCfg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">removeParameterSet&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">drtCfg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getDrtInsertionSearchParams&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">drtCfg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">addParameterSet&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ExtensiveInsertionSearchParams&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>For &lt;strong>Repeated Selective Search&lt;/strong>:
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">drtCfg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">removeParameterSet&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">drtCfg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getDrtInsertionSearchParams&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">drtCfg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">addParameterSet&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">RepeatedSelectiveInsertionSearchParams&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Run your simulation&lt;/strong> as usual:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Controler&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">controller&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">DrtControlerCreator&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">createControler&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">config&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">controller&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">run&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol>
&lt;h3 id="-configuration-parameters">🔧 Configuration Parameters
&lt;/h3>&lt;div style="font-size: 0.85em">
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Parameter&lt;/th>
&lt;th>Description&lt;/th>
&lt;th>Default&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>collectionPeriod&lt;/code>&lt;/td>
&lt;td>Time window (in seconds) for collecting incoming requests before processing begins. Larger values increase batching but may delay responsiveness.&lt;/td>
&lt;td>&lt;code>15.0&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>maxIterations&lt;/code>&lt;/td>
&lt;td>Maximum number of conflict resolution iterations. Helps resolve cases where multiple partitions assign requests to the same vehicle.&lt;/td>
&lt;td>&lt;code>2&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>maxPartitions&lt;/code>&lt;/td>
&lt;td>Maximum number of partitions (i.e., parallel workers). Each partition processes a subset of requests and vehicles.&lt;/td>
&lt;td>&lt;code>4&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>insertionSearchThreadsPerWorker&lt;/code>&lt;/td>
&lt;td>Number of threads allocated per worker for performing insertion searches.&lt;/td>
&lt;td>&lt;code>4&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>logThreadActivity&lt;/code>&lt;/td>
&lt;td>Enables logging of thread activity and request density. Useful for diagnostics and benchmarking.&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>vehiclesPartitioner&lt;/code>&lt;/td>
&lt;td>Strategy for partitioning vehicles across workers. Options:&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;p>These parameters allow you to balance performance, parallelism, and conflict resolution quality depending on your scenario scale and hardware capabilities.&lt;/p>
&lt;p>For a complete example, refer to the &lt;a class="link" href="https://github.com/matsim-org/matsim-libs/blob/main/contribs/drt/src/test/java/org/matsim/contrib/drt/run/examples/RunDrtExampleIT.java#L88" target="_blank" rel="noopener"
>&lt;code>RunDrtExampleIT.java&lt;/code>&lt;/a> integration test, which demonstrates various configurations.&lt;/p>
&lt;h2 id="-conclusion">🧠 Conclusion
&lt;/h2>&lt;p>The &lt;code>ParallelUnplannedRequestInserter&lt;/code> is a powerful enhancement for MATSim’s DRT module, enabling &lt;strong>scalable, high-performance simulations&lt;/strong> that are essential for future mobility planning. Whether you&amp;rsquo;re simulating autonomous fleets or optimizing MaaS strategies, this tool ensures that your simulations remain &lt;strong>fast, reliable, and adaptable&lt;/strong> — even at large scale.&lt;/p>
&lt;p>By leveraging &lt;strong>parallel processing&lt;/strong> and &lt;strong>dynamic partitioning&lt;/strong>, it significantly improves the &lt;strong>economic feasibility of large-scale studies&lt;/strong>. Simulations that previously required hours or days can now deliver actionable insights in a fraction of the time. This acceleration not only reduces computational costs but also shortens the time to decision-making — a critical factor in agile urban planning and transport strategy development.&lt;/p>
&lt;p>A logical next step is to &lt;strong>combine these optimizations with DSim (Distributed MATSim)&lt;/strong>, enabling distributed execution across multiple machines or clusters. This will unlock even greater scalability, allowing researchers and planners to simulate entire regions or countries with high fidelity and responsiveness.&lt;/p>
&lt;hr>
&lt;div align="center">Stay tuned for the next iteration &lt;img src="https://iteratively.io/logo_iteratively_circle.svg" style="height:1.5em;position:relative;top:0.4em;padding-left:0.2em"> &lt;/div>
&lt;p>&lt;em>Author: Steffen Axer&lt;/em>&lt;/p></description></item></channel></rss>